# 基础

## 排序
 - 稳定排序：冒泡
 - 不稳定排序：：直接插入排序 、冒泡排序、归并排序和基数排序
 -  选择、冒泡、插入均为 O(n^2)
 ```
 // --- C++ --- //
 #include <algorithm>
 sort(buf, buf+n);
 // ---  C  ----//
 #include <stdlib.h>
 ```

## 日期
 - 涉及日期的使用c比较方便，速度也快
 - 日期建议使用差值算出，如今天星期几、一年中的第几天、日期差值都能够用待求日期与公元第一天的差值算出

## 打印模式
 - 使用C可能更灵活
 - 必要时使用双缓冲

## 查找
 - 二分法
 ```
 while(l <= r) {
   m = (l + r) / 2;
   if (a[m] < target) l = m + 1; // m + 1 而不是 m
   else if (a[m] > target) r = m - 1; // m - 1 而不是 m
   else // hit
 }
 ```

## 贪心算法
### **背包问题(无特殊说明只能取整个物体)**
**思路**: 反证法，证明当前策略不丢失最优解，或者就是最优解
  - 背包可承受重量C
  1. n件物品(w)重量各不同，使背包装**数量最多**的物品。`直接从重量最轻的开始装包`
  2. n件物品(w,v)重量，价值各不同，物品可取一部分，使背包装**价值最高**的物品。`计算价值重量比v，从v大的开始装包`
  3. n件物品(w)重量各不同，**每个背包最多只能装2件**，使装下所有物品所需**背包数最少**。`最轻的跟最重的装一起，不能装在一起的单独装`
### **区间(a,b)问题**
 1. 不相交区间**数量最多**。`根据b进行排序，选择b最小的一个，剔除所有相交区间，继续选择b最小的`
 2. 选择**最少公共点**覆盖所有区间。`根据b->a排序，选择最小的b为公共点，剔除所有相交区间，继续选择最小的b`
 3. 选择**最少区间**覆盖[s,t]。`根据a排序，截断s前的部分，选择最长的区间；新的s为最长区间的终点`
### **哈夫曼编码**

# 数据结构
## 栈
 - 先进后出
 - 栈也可以直接用数组+索引实现
 - 栈类型的题目包括**表达式计算**，需要考虑优先级: `) > * or / > + or -`
 - 表达式求值思路：**判断上一个运算符的优先级**、**在操作符栈底push一个终止符**

## 哈夫曼树
 - 使用优先级实现

## 二叉排序树
 - 删除：使用**没有重复节点的分支**替代被删除节点

# 数学问题
## %
 - 运行时错误可能为`mod 0`
 - "安全"的`mod`: `(a % b + b) % b`
```
// C standard integer pow
int ipow(int base, int exp)
{
    int result = 1;
    for (;;)
    {
        if (exp & 1)
            result *= base;
        exp >>= 1;
        if (!exp)
            break;
        base *= base;
    }

    return result;
}
```

## 最大公约数
 - 辗转相除法
```
int gcd(int a, int b) {
    if (b == 0) return a;
    else return gcd(b, a % b);
}
```

## 素数判定
 - 直接法
```
bool isPrime(int N) {
    int bound = (int)sqrt(N);
    for (int i = 2; i <= bound; i++)
        if (N % i == 0) return false;
    return true;
}
```

# 补充

## 正确性
 - 注意边界值如 0，/0等
 - 注意不大于、不小于、大于、小于、等于的边界
 - `longlong = int + int`计算顺序为`int + int`, `long long (result)`

## 时间复杂度
 - 1s 约 运算 10^8，保守估计10^6次
